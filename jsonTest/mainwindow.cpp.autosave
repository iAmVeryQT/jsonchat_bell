#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <QMessageBox>
#include <QJsonDocument>
#include <QStandardPaths>
#include <iostream>
#include <QHBoxLayout>
#include <QObjectUserData>
#include <QPushButton>
using namespace std;
//using namespace UsersManagement;
//using namespace FileBox;
#include <QFileDialog>
#include <QDir>
#define STR(A) QString::fromWCharArray(L##A)
#define KOREAN(STR) QString::fromWCharArray(L##STR)


/*
 * << 파일관리 >>
 *
 * 송신자
 * 파일경로
 *
 * */
class MyData: public QObjectUserData
{
public:
    QString mSender;
    QString mFilePath; // 상대가 준 path (송신한 입장)
};


/*
 * < 사용자 정보 >>
 *
 * (입장한) 사용자
 * 사용자 명 수
 *
 * */
class UserData: public QObjectUserData
{
public:
    QString mUser;
    QString mUserNumber;
};



MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    connect(&soketQt, SIGNAL(readyRead()), this, SLOT(onReceive()));

    ui->AddressEdit->setText("boss2d.com");
    roomNum = "123";
/*
    QDir TargetDir;
    TargetDir = QStandardPaths::standardLocations(QStandardPaths::DataLocation).value(0).toUtf8();
    const QStringList& List = TargetDir.entryList(QDir::Files|QDir::Dirs|QDir::Hidden|QDir::System|QDir::NoDotAndDotDot);
    for(int i=0,iend=List.size(); i<iend; ++i)
    {

    }
*/




    /* 윈도우 모달 생성 중 */


    QDir FileList;
    FileList = QStandardPaths::standardLocations(QStandardPaths::DownloadLocation).value(0);

    // # QStringList 는 양방향 연결구조이다.
    // # 삽입, 삭제가 용이한 점을 이용하자.
    // 디렉토리 경로를 StringList에 저장해서 크기가 가변적인 데이터에 대응.
    const QStringList& List = FileList.entryList(QDir::Files|QDir::Dirs|QDir::Hidden|QDir::System|QDir::NoDotAndDotDot);
    // 경로크기만큼
    for(int i=0,iend=List.size(); i<iend; ++i)
    {
        ui->ShowFiles->addItem(List[i]);
    }


}



MainWindow::~MainWindow()
{

    delete ui;

    //가변배열을 한바퀴 돌기위한 반복자
    foreach(auto& iFile, mFileList)
    {
        if(iFile != nullptr)
        {
            iFile->remove();
            delete iFile;

        }
    }

    //auto iFile = mFileList.at(i);
    //for(int i=0; i < mFileList.length(); ++i)
    //{
      //  auto &iFile = mFileList.at(i);
        //엠퍼센트를 쓰면
    //}
}


/*void MainWindow::on_aabbcc_textChanged()
{

    QString a= ui->aabbcc->toPlainText();

    if(a.right(1)=="\n")
    {
        a.resize(a.size()-1);
        //QMessageBox(QMessageBox::Information,"hello world~~",a).exec();
        soketQt.connectToHost(a,10125);
        if(soketQt.waitForConnected(5000))
           {
                QMessageBox(QMessageBox::Information,"hello world~~",a).exec();
           }
        else
          {
                QMessageBox(QMessageBox::Information,"error!!!",a).exec();

          }

        ui->aabbcc->setText(a);

        QTextCursor cursor = ui->aabbcc->textCursor();
        cursor.movePosition(QTextCursor::End);
        ui->aabbcc->setTextCursor(cursor);
    }

}*/

/*void MainWindow::on_lineEdit_returnPressed()
{
    QString a= ui->TalkEdit->text();
     QString json = "#json begin {";
     //json += "{";
     json += "'type':'chat',";
     json += "'room':'r123',";
     json += "'text':'"+a+"'";
     json += "} #json end";

     soketQt.write(json.toUtf8().constData());
}*/

void MainWindow::onReceive()
{


    //수신입장

    //소켓 받아오기
    QTcpSocket* Peer = (QTcpSocket*) sender();
       qint64 PacketSize = Peer->bytesAvailable();

       if(0 < PacketSize)
       {
           char* PacketBuffer = new char[PacketSize + 1];
           Peer->read(PacketBuffer, PacketSize);
           PacketBuffer[PacketSize] = '\0';
           //QMessageBox(QMessageBox::Information,"hello",PacketBuffer).exec();


           QString jasonString = PacketBuffer;
           delete[] PacketBuffer;

           jasonString.remove("#json begin");
           jasonString.remove("#json end");


           //받을 데이터 타입
            QJsonDocument json = QJsonDocument::fromJson(jasonString.toUtf8());
            auto subType = json["subtype"].toString();
            //QString
            auto text = json["text"].toString("");
            //QString
            auto name = json["name"].toString("noName");
            //ui->TalkList->addItem("["+c+"]"+b);


            //데이터 처리
            if(subType =="fileshare")
            {

                 ui->TalkList->addItem("~~~");
                 QListWidgetItem* NewItem = new QListWidgetItem();
                 NewItem->setBackgroundColor(QColor(255,20,200));
                 NewItem->setSizeHint(QSize(0,100));
                 ui->TalkList->addItem(NewItem);

                 //MyData*
                 auto NewFilePath = json["filepath"].toString();
                 auto NewData = new MyData();
                 NewData->mSender = name;
                 NewData->mFilePath = NewFilePath;

                 // ShowFiles 에서 전송
                 QPushButton* button = new QPushButton("file download");
                 button->setUserData(0,NewData);

                 // Widget 간의 연결
                 connect(button, SIGNAL(pressed()),this,SLOT(DownloadBtn()));

                 // 보낼 레이아웃구조 생성
                 QHBoxLayout* NewLayout = new QHBoxLayout();
                 NewLayout->addWidget(button);
                 NewLayout->addWidget(new QLabel(text));


                // TalkList 뷰에 생성
                 QWidget* NewWidget = new QWidget();
                 NewWidget->setLayout(NewLayout);

                 ui->TalkList->setItemWidget(NewItem,NewWidget);


                 //

            }
            else if(subType =="getfile")
            {


            }
            else if(subType =="setfile") //파일 조각에 대한 교신을 받는다.
            {
               // 디버깅
               // QMessageBox(QMessageBox::Information,"setFile is on~~",json.toJson().constData()).exec();


                //QMessageBox(QMessageBox::Information,"0000000000",json.toJson().constData()).exec();

                auto Base64 = json["base64"].toString();

                QByteArray aa(Base64.toUtf8().constData()); // ## 속도 개선 가능성...
                QByteArray NewBuffer = QByteArray::fromBase64(aa);



                //QMessageBox(QMessageBox::Information,"111111",json.toJson().constData()).exec();

                QFile WriteFile("aaa.txt");

                //QMessageBox(QMessageBox::Information,"222222222",json.toJson().constData()).exec();

                if(WriteFile.open(QFileDevice::WriteOnly))
                {
                    //QMessageBox(QMessageBox::Information,"33333333",json.toJson().constData()).exec();

                    //int Base64.toUtf8().constData();
                    //WriteFile.write(Base64.toUtf8().constData(),Base64.length());
                    //QMessageBox(QMessageBox::Information,"44444444",json.toJson().constData()).exec();

                    WriteFile.write(NewBuffer);
                    WriteFile.close();
                    //QMessageBox(QMessageBox::Information,"5555555",json.toJson().constData()).exec();

                }

                //QMessageBox(QMessageBox::Information,"666666666",json.toJson().constData()).exec();

                auto NewItem = new QListWidgetItem("<"+name+">"+text);
                NewItem->setBackgroundColor(QColor(224,255,192));
                ui->TalkList->addItem(NewItem);

                auto FileID = json["fileid"].toString().toInt();
                auto Done = json["done"].toString().toInt();
                //auto Base64 = json["base64"].toString();


                //**************
                if(auto CurFile = mFileList.at(FileID))
                {
                    QMessageBox(QMessageBox::Information,"666666666",json.toJson().constData()).exec();

                    QByteArray NewBase64(Base64.toUtf8().constData());
                    QByteArray NewBuffer = QByteArray::fromBase64(NewBase64);
                    CurFile->write(NewBuffer);

                    if(Done==1)
                    {

                        QMessageBox(QMessageBox::Information,"77777776",json.toJson().constData()).exec();
                        CurFile->close();
                        auto OldFileName = CurFile->fileName();
                        CurFile->rename(OldFileName.left(OldFileName.length()-9));
                        delete CurFile;
                        mFileList.replace(FileID,nullptr);
                    }
                }



            }

            else
            {
                 ui->TalkList->addItem("[" + name + "]" + text);
            }

            ////////////////
            ////////////////
            ///
            /*if(true)
            {
                QIcon img("../image/in-love.png"); //역슬래쉬 쓰려면 두번 써야한다.  "//"
                QListWidgetItem* item = new QListWidgetItem(img, b);
                ui->TalkList->addItem(item); //qt에서 알아서 delete해줌
            }
            else{
                ui->TalkList->addItem("["+c+"]"+b);
            }*/


           //ui->TalkList->addItem(jasonString);


           //ui->TalkList->addItem("ab");
       }
}


//주소버튼
void MainWindow::on_AddressEdit_textChanged(const QString &arg1)
{
    address = arg1;

}

//접속버튼
void MainWindow::on_ConnectBtn_clicked()
{

    soketQt.connectToHost(address,10125);
    if(soketQt.waitForConnected(5000))
       {
            //QMessageBox(QMessageBox::Information,"hello world~~",address).exec();
            ui->TalkEdit->setEnabled(true);
            ui->TalkList->setEnabled(true);
       }
    else
      {
            QMessageBox(QMessageBox::Information,"error!!!",address).exec();

      }
}

//채팅박스 - 편집
void MainWindow::on_TalkEdit_textEdited(const QString &arg1)
{
    textMessage = arg1;

}


//채팅박스 - 엔터키로 대화 전송
void MainWindow::on_TalkEdit_returnPressed()
{

    //데이터 타입
    QString json = "#json begin {";
     //json += "{";
     json += "'type':'chat',";
     json += "'room':'"+roomNum+"',";
     json += "'name':'"+name+"',"; //필드를 지워버리면 noName이 나온다..
     json += "'text':'"+textMessage+"'";
     json += "} #json end";


     //송신
     soketQt.write(json.toUtf8().constData());

     //display
     ui->TalkList->scrollToBottom(); // 대화내용 스크롤링하기

     //송신 후 글 없애주기
     ui->TalkEdit->clear();

}


/*
 *
 * < 사용자 정보 >>
 *
 * (입장한) 사용자
 * 사용자 명 수
 *
 *
class UserData: public QObjectUserData
{
public:
    QString mUser;
    QString mUserNumber;
};
*/

//유저 이름
void MainWindow::on_UserName_textEdited(const QString &arg1)
{

    name = arg1;

    //<1>
    //
    // 유저 객체 받아오기
    // 유저 멤버변수 이용하기
           auto NewUser = new UserData;
           NewUser->mUser = name;

        for(int j=0, jend=NewUser->mUser.size(); j<jend; ++j)
        {
             //ui->ShowUsers->addItem(name[j]);
             NewUser->mUserNumber += NewUser->mUser;
             ui->ShowUsers->addItem(NewUser->mUser);
        }
        
        //이슈1 : 유저가 네임을 바꾸면 계속 뜬다....
        //이슈2 : 여러번 뜬다.
        // 머리아프니까 나중에

//    const QStringList& List = FileList.entryList(QDir::Files|QDir::Dirs|QDir::Hidden|QDir::System|QDir::NoDotAndDotDot);
//        // 경로크기만큼
//        for(int i=0,iend=List.size(); i<iend; ++i)
//        {
//            ui->ShowFiles->addItem(List[i]);
//        }

}


//방번호
void MainWindow::on_RoomName_textEdited(const QString &arg1)
{
    roomNum = arg1;
}





/*
////////<2> QPushButton 새로 저장하기 메서드에 TalkList의 레이아웃 위젯기능 똑같이 구현
*/



/*
////////////////////////<3> QPushButton 의 이모지 파일을 불러온다.
/// 간단하게 팝업창으로 최근 썼던 이모지를 띄운다.
/// 띄우는 데에는 DP 알고리즘을 이용한다.
///

*/





//파일전송 버튼
void MainWindow::on_SendFile_pressed()
{
    auto List = ui->ShowFiles->selectedItems();
     if(0 < List.length())
     {
         const QString ShortName = List[0]->text();

    // const QString FilePath = ui->ShowFiles->;
     QString FullName = QStandardPaths::standardLocations(QStandardPaths::DownloadLocation).value(0) + "/" + ShortName;
     const int64_t FileSize = QFileInfo(FullName).size();
    // QString ShortName; // 파일path에서 실제 파일네임만 뺀 이름.
     //FilePath.lastIndexOf("/");

         QString json = "#json begin {";
          json += "'type':'chat',";
          json += "'room':'"+roomNum+"',";
          json += "'name':'"+name+"',";
          json += "'text':'" + name + " user sends for a File[" + ShortName
              + "(" + QString::number(FileSize) + "Byte)].',";
          json += "'subtype':'fileshare',";
          json += "'filepath':'" + ShortName +"'";
          json += "} #json end";


          soketQt.write(json.toUtf8().constData());

     }


}


//채팅박스 내 리스트에서 display
//다운로드 버튼
 void MainWindow::DownloadBtn()
 {
    //QMessageBox(QMessageBox::Information,"Debug","aaaaa").exec();
    //QPushButton* Btn =
     if(auto Btn = qobject_cast<QPushButton*>( sender() ))
     {

        //Btn->userData(0);
        /* args ( 부모 파라미터, 메시지, ) */
        //QFileDialog Dialog (nullptr, QString::fromWCharArray(L"전송받을 폴더 알려주세요"));
        QFileDialog Dialog (nullptr, STR("전송받을 폴더 알려주세요"));
        Dialog.setFileMode(QFileDialog::Directory);
        if(Dialog.exec())
        {


            const QString DirPath = Dialog.selectedFiles()[0];
            //QMessageBox(QMessageBox::Information, "Debug", DirPath).exec();


            //auto List = ui->ShowFiles->selectedItems();
            //const QString ShortName = List[0]->text();
            // const QString FilePath = ui->ShowFiles->;
            //QString FullName = QStandardPaths::standardLocations(QStandardPaths::DownloadLocation).value(0) + "/" + ShortName;
            //const int64_t FileSize = QFileInfo(FullName).size();

            auto Data = (MyData*)Btn->userData(0);


            QString ShortName;
            //short path 만들기 . 제일 마지막 슬래시 위치파악
            int SlashPos = Data->mFilePath.lastIndexOf('/');
            if( SlashPos == -1 )
                ShortName = Data-> mFilePath;
            else
                ShortName = Data->mFilePath.right(Data->mFilePath.length()-SlashPos-1);


            QFile* WriteFile = new QFile(DirPath+"/"+ShortName+".download"); // 확장자는 구분하는 이름일 뿐이다. 의미없음.
            if(WriteFile->open(QFileDevice::WriteOnly))
            {

                int FileID = mFileList.length();
                //.append 는 제일 마지막에 꽂아넣기.
                mFileList.append(WriteFile);


                QString Msg = "#json begin {";
                //....
                Msg += "fileid':'" + QString:: number(FileID) + "'";
                Msg += "}#json end";

                soketQt.write(Msg.toUtf8().constData());

            }



            //데이터는 앞쪽경계선

            // 선언과 = 는 "초기화"
            //  = 는 "대입"
            //이라 부른다.

            // 초기화 타이밍
            // 초기화 리스트의 존재 이유는 const int b; 와 같은 경우 때문이다. 대입을 못하니까 생성자 아규먼트에서 선언해줌.
            // const 가 적혀있는 선언문은 반드시 초기화 리스트를 작성해준다.
            // 주소변환 금지 int* const a;  =======> 0으로 초기화해준다.
            // 값 변환 금지 const:: int b ;   =======> nullptr로 초기화 해준다.

            QString Msg = "#json begin {";
            Msg += "'type':'chat',";
            Msg += "'room':'"+roomNum+"',";
            Msg += "'name':'"+name+"',";
            Msg += KOREAN("'text':' 파일받기를 시작합니다',");

            Msg += "'subtype':'getfile',";
            Msg += "'sender':'"+ Data->mSender+"',";
            Msg += "'filepath':'" + Data->mFilePath +"',";
            Msg += "'fileid':'0'";
            Msg += " } #json end";
            soketQt.write(Msg.toUtf8().constData());

        }

        //dynamic_cast<QPushButton*>( sender() );   //( QPushButton*)sender();
        //Btn->userData(0);

        // c++은 0 외 모두 성공
        // JAVA, C# 은 불린형식으로 !=0 처럼 해준다.

        //MyData* OneData =(MyData*)Btn->userData(0);
        //OneData->mFilePath;
        //QMessageBox(QMessageBox::Information,"Debug",OneData->mFilePath).exec();
    }
 }


